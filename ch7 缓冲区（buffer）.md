本章我们将学习缓冲区（Buffers）抽象的概念。前一章中我们已了解统一共享内存（USM）——这种基于指针的数据管理策略。<font style="color:#74B602;">USM要求开发者必须关注内存的物理位置及各处的可访问性</font>，而缓冲区抽象作为更高层次的模型，则向程序员隐藏了这些细节。<font style="color:#DF2A3F;">缓冲区仅作为数据的表征载体，其存储方式与内存中的迁移管理将由运行时系统自动完成</font>。  

本章提出了一种管理数据的替代方法。在缓冲区和USM之间的选择通常取决于个人偏好及现有代码风格，且<font style="background-color:#E8F7CF;">应用程序可以自由混合使用这两种风格来表示内部的不同数据</font>。  

<font style="color:#DF2A3F;">USM仅针对内存提供了不同的抽象层级</font>。USM采用指针机制，而缓冲区则是更高层次的抽象。<font style="color:#DF2A3F;background-color:#FBF5CB;">缓冲区的抽象层级允许其中包含的数据在应用程序内的任何设备上使用，运行时系统会自行管理所需机制以确保数据可用</font>。对于采用基于指针的数据结构（如链表、树形结构等）的应用程序而言，USM的指针模型可能更为适用。<font style="background-color:#E8F7CF;">若现有代码已广泛使用指针，则缓冲区机制的改造可能更具挑战性</font>。但<font style="background-color:#FBF5CB;">缓冲区能确保在系统所有设备上运行</font>，而某些设备可能不支持特定（或所有）USM模式。多一种选择总是好的，现在让我们深入探讨缓冲区机制。  

我们将更详细地探<font style="background-color:#CEF5F7;">讨缓冲区的创建与使用方法</font>。讨论缓冲区时若不涉及访问器，则论述将不够完整。缓冲区虽然抽象化了程序中数据的表示与存储方式，但我们<font style="background-color:#FBE4E7;">并不直接通过缓冲区操作数据，而是借助访问器对象——这些对象会向运行时环境声明数据的预期使用方式，且访问器与任务图中强大的数据依赖机制紧密关联</font>。在全面介绍缓冲区的功能后，我们还将探索如何在程序中创建和使用访问器。  

## 缓冲区（Buffers）
缓冲区是数据的高级抽象。<font style="background-color:#E8F7CF;">缓冲区未必绑定于单一物理位置或虚拟内存地址</font>。实际上，<font style="color:#DF2A3F;background-color:#CEF5F7;">运行时系统可自由使用内存中的多个不同位置（甚至跨不同设备）来表示缓冲区</font><font style="background-color:#CEF5F7;">，但必须确保始终提供数据的一致性视图</font>。<font style="color:#DF2A3F;background-color:#FBF5CB;">缓冲区可在主机端和任意设备端访问</font>。  

```cpp
template <typename T, int Dimensions, AllocatorT allocator> class buffer;
```

缓冲区类是一个具有三个模板参数的模板类，如图7-1所示。第一个模板参数是缓冲区所包含对象的类型。该类型必须是设备可复制的，这一概念扩展了C++定义的平凡可复制类型（ trivially copyable ）。平凡可复制类型可以通过逐字节复制实现安全拷贝，而无需使用任何特殊的复制或移动构造函数。设备可复制类型将这一概念递归扩展到某些C++类型（如std::pair或std::tuple）。第二个模板参数是描述缓冲区维度的整数值。最后一个模板参数为可选参数，默认情况下通常使用value值。该参数指定了一个C++风格的分配器类，用于执行缓冲区所需的宿主机内存分配操作。首先，我们将探讨创建缓冲区对象的多种方式。  

### 创建缓冲区
 在下列图表中，我们将展示创建缓冲对象(buffer objects)的几种方式。让我们逐步解析示例并逐一审视每种情况。  

```cpp
// 使用默认分配器创建2x5的int型缓冲区  
buffer<int, 2, buffer_allocator<int>> b1{range<2>{2, 5}};  

// 使用默认分配器并通过CTAD（类模板实参推导）创建2x5的int型缓冲区  
buffer<int, 2> b2{range{2, 5}};  

// 使用默认构造的std::allocator创建包含20个float型元素的缓冲区  
buffer<float, 1, std::allocator<float>> b3{range{20}};  

// 使用传入的分配器创建包含20个float型元素的缓冲区  
std::allocator<float> myFloatAlloc;  
buffer<float, 1, std::allocator<float>> b4{range(20), myFloatAlloc};
```

我们在图7-2中创建的第一个缓冲区b1是一个包含十个整数的二维缓冲区。我们显式传递了所有模板参数，甚至明确将buffer_allocator<T>的默认值作为分配器类型传递。由于buffer_allocator同样是模板类型，我们必须像处理缓冲区那样通过指定buffer_allocator<int>来显式特化它。然而，使用现代C++语法可以更简洁地表达这一点。缓冲区b2同样是一个使用默认分配器的包含十个整数的二维缓冲区。此处我们利用了C++17的类模板参数推导（CTAD）功能来自动推断模板参数。CTAD是遵循全有或全无原则的工具——它必须推断类的所有模板参数，或完全不推断任何参数。在本例中，我们利用初始化b2时使用了接受两个参数的区间这一事实，推断出这是一个二维区间。分配器模板参数具有默认值，因此在创建缓冲区时无需显式列出该参数。 

使用缓冲区b3时，我们创建了一个包含20个浮点数的缓冲区，并通过默认构造的std::allocator在主机上分配所需内存。当为缓冲区配置自定义分配器类型时，通常需要向缓冲区传递实际分配器对象以替代默认构造的实例。缓冲区b4的示例演示了实现方式——在构造函数调用中，将分配器对象置于数据范围参数之后传入。  

在我们的示例中，前四个缓冲区<font style="color:#DF2A3F;">允许动态分配所需内存</font>，<font style="color:#DF2A3F;">且在创建时不对其数据进行初始化</font>。常见做法是利用缓冲区封装已有的C++内存分配——这些内存可能已包含初始化数据。通过向缓冲区构造函数传递初始值源，我们能够实现多项功能，这将在下一个示例中具体展示。

```cpp
// 创建一个包含4个double类型数据的缓冲区，并通过主机指针进行初始化  
double myDoubles[4] = {1.1, 2.2, 3.3, 4.4};  
buffer b5{myDoubles, range{4}};  

// 创建一个包含5个double类型数据的缓冲区，并通过指向常量的主机指针进行初始化  
const double myConstDbls[5] = {1.0, 2.0, 3.0, 4.0, 5.0};  
buffer b6{myConstDbls, range{5}};  

// 通过指向int的共享指针创建缓冲区  
auto sharedPtr = std::make_shared<int>(42);  
buffer b7{sharedPtr, range{1}};
```

在图7-3中，缓冲区b5创建了一个包含四个双精度浮点数的一维缓冲区。除了指定缓冲区大小的范围参数外，我们还将指向C数组myDoubles的主机指针传递给缓冲区构造函数。此处我们可以充分利用CTAD（类模板实参推导）来推断缓冲区的所有模板参数：传递的双精度指针确定了缓冲区的数据类型；一维范围自动推导出维度数量（该范围本身仅通过单个数值创建即可推导）；最后由于使用默认分配器，因此无需额外指定。  

<font style="color:#DF2A3F;background-color:#FBF5CB;">传递主机指针存在若干需要注意的影响因素</font>。<font style="background-color:#E8F7CF;">通过传递指向主机内存的指针，我们向运行时系统承诺在缓冲区生命周期内不会尝试访问该主机内存</font>。SYCL实现无法（也不可能）强制执行这一约束——确保不违反此约定是我们的责任。避免在缓冲区存活期间访问该内存的一个原因是：出于优化考虑，<font style="background-color:#E8F7CF;">缓冲区可能会选择使用主机上的不同内存来存储缓冲区内容</font>。若发生这种情况，数据将从原始主机指针复制至新内存中。<font style="color:#2F4BDA;">若后续内核修改了缓冲区内容，原始主机指针在特定同步点之前不会反映更新后的数值</font>。关于数据何时写回主机指针的详细讨论，我们将在本章后续部分展开。  

缓冲区b6与缓冲区b5非常相似，但存在一个主要差异。 这次我们<font style="color:#DF2A3F;background-color:#FBF5CB;">使用指向const double的指针初始化缓冲区</font>。这意味着<font style="background-color:#CEF5F7;">只能通过主机指针读取数值，而不能进行写入操作</font>。 不过在本例中，缓冲区的类型仍为double而非const double，因为类型推导指南不会考虑const限定符。 这表明内核仍可能向缓冲区写入数据，但当缓冲区超出使用范围后（本章后续将讨论），我们必须采用其他机制来更新主机端数据。

<font style="color:#DF2A3F;">缓冲区也可通过C++共享指针对象进行初始化</font>。若应用程序已采用共享指针，此初始化方式能准确统计引用计数并确保内存不被释放，具有实用价值。缓冲区b7创建了一个包含单个整数的缓冲区，并通过共享指针完成初始化。  

```cpp
// 从输入迭代器创建整型缓冲区  
std::vector<int> myVec;  
buffer b8{myVec.begin(), myVec.end()};  
buffer b9{myVec};  

// 创建一个2x5整型缓冲区及两个互不重叠的  
// 5整型子缓冲区  
buffer<int, 2> b10{range{2, 5}};  
buffer b11{b10, id{0, 0}, range{1, 5}};  
buffer b12{b10, id{1, 0}, range{1, 5}};
```

容器在现代C++应用程序中被广泛使用，典型实例包括std::array、std::vector、std::list和std::map。我们可以通过两种不同方式利用容器初始化一维缓冲区。第一种方式如图7-4中缓冲区b8所示，采用输入迭代器：向缓冲区构造函数传递两个迭代器（一个标识数据起始位置，另一个标识结束位置），而非主机指针。缓冲区大小通过递增起始迭代器直至其等于结束迭代器所遍历的元素数量计算得出。这种方法适用于所有实现C++输入迭代器接口的数据类型。若为缓冲区提供初始值的容器对象同时满足连续存储特性，则可使用更简洁的创建形式。缓冲区b9通过直接向构造函数传递vector容器创建，其大小由初始化容器的尺寸决定，缓冲区数据类型则继承自容器元素的类型。对于std::vector和std::array这类容器，采用这种创建方式既符合惯例也值得推荐。  

缓冲区创建的最后一个示例展示了buffer类的另一特性：可以创建<font style="color:#DF2A3F;background-color:#CEF5F7;">子缓冲区</font>（sub-buffer），即<font style="background-color:#E8F7CF;">基于现有缓冲区生成视图</font>。<font style="color:#DF2A3F;background-color:#E8F7CF;">创建子缓冲区需满足三个条件</font>：<font style="background-color:#E8F7CF;">父缓冲区的引用</font>、<font style="background-color:#E8F7CF;">基准索引</font>以及<font style="background-color:#E8F7CF;">子缓冲区范围</font>。子缓冲区不可由其他子缓冲区派生，但<font style="background-color:#E8F7CF;">允许从同一父缓冲区创建多个可重叠的子缓冲区</font>。缓冲区b10的创建方式与b2完全相同——均为每行含五个整数的二维整数缓冲区。随后我们从b10派生出两个子缓冲区b11和b12：b11起始于索引(0,0)并包含首行所有元素，b12起始于(1,0)并包含第二行全部元素，由此生成两个互不相交的子缓冲区。由于这些子缓冲区不存在重叠区域，不同内核可对它们执行并行操作。关于执行图调度与依赖关系的详细讨论，我们将在下一章展开。  

```cpp
queue q;  
int my_ints[42];
// 创建包含42个整数的缓冲区
buffer<int> b{range(42)};
// 创建包含42个整数的缓冲区，并通过主机指针初始化，添加use_host_pointer属性
buffer b1{my_ints, range(42), {property::buffer::use_host_ptr{}}}; 
// 创建包含42个整数的缓冲区，并通过主机指针初始化，添加use_mutex属性  
std::mutex myMutex;  
buffer b2{my_ints, range(42), {property::buffer::use_mutex{myMutex}}};  
// 获取该缓冲区使用的互斥锁指针  
auto mutexPtr = b2.get_property<property::buffer::use_mutex>().get_mutex_ptr();  
// 锁定互斥锁直至退出作用域  
std::lock_guard<std::mutex> guard{*mutexPtr};  
// 创建绑定到上下文的包含42个整数的缓冲区，通过主机指针初始化  
buffer b3{ my_ints, range(42), {property::buffer::context_bound{q.get_context()}}};
```

#### 缓冲区属性
缓冲区也可通过设置特殊属性来改变其行为特性。在图7-5中，我们将逐步演示三种可选缓冲属性的应用实例，并探讨其使用场景。需注意的是，<font style="background-color:#E8F7CF;">这些属性在大多数代码中较为罕见</font>。  

##### use_host_ptr
在缓冲区创建时可选的第一个属性是`<font style="color:#DF2A3F;">use_host_ptr</font>`。<font style="background-color:#E8F7CF;">该属性存在时，会要求缓冲区不在主机端分配任何内存，且传入或在缓冲区构造时指定的分配器均被实际忽略</font>。<font style="color:#DF2A3F;">缓冲区必须使用传递给构造函数的主机指针所指向的内存</font>。需注意这并不要求设备端使用相同内存存储缓冲区数据，设备可自由在其附属内存中缓存缓冲区内容。另请注意<font style="background-color:#E8F7CF;">该属性仅当主机指针被传入构造函数时方可使用</font>。当程序希望完全掌控所有主机内存分配时（例如允许程序员试图最小化应用程序内存占用），此选项将非常实用。  

在图7-5的示例中，我们按照先前示例的方法创建了缓冲区b。接着创建缓冲区b1并用指向myInts的指针对其进行初始化。同时我们传入use_host_ptr属性，这意味着缓冲区b1将仅使用myInts所指向的内存，而不会在主机上分配任何额外的临时存储空间。  

##### use_mutex
 下一属性`<font style="color:#DF2A3F;">use_mutex</font>`涉及缓冲区与主机代码之间的细粒度内存共享。示例中创建的缓冲区`b2`即采用此属性。<font style="background-color:#FBF5CB;">该属性需传入互斥锁对象的引用，后续可通过缓冲区查询该锁</font>（如示例所示）。<font style="background-color:#FBF5CB;">此属性还要求向构造函数传递主机指针，使运行时能判定何时可通过该主机指针安全访问主机代码中的更新值</font>。在运行时确保主机指针获取缓冲区最新值之前，不得锁定互斥锁。该属性虽可与`use_host_ptr`属性结合使用，但非必须。`use_mutex`是一种允许主机代码访问缓冲区内数据的机制，缓冲区仍然有效且未使用主机访问器机制（后文详述）。通常应优先采用主机访问器机制，除非存在特定理由需使用互斥锁——尤其因为无法保证互斥锁成功锁定及数据可供主机代码使用的具体耗时。  

##### context_bound
最后一项特性体现在示例中缓冲区b3的创建过程。此处，我们创建的42个整数缓冲区带有`<font style="color:#DF2A3F;">context_bound</font>`属性。<font style="background-color:#E8F7CF;">该属性接收上下文对象的引用</font>。通常，缓冲区可自由用于任何设备或上下文。但若<font style="background-color:#E8F7CF;">使用此属性，则会将缓冲区锁定至指定上下文</font>。<font style="color:#2F4BDA;">尝试在其他上下文使用该缓冲区将引发运行时错误</font>。<font style="background-color:#D9EAFC;">该特性在调试程序时颇具价值</font>，例如可帮助识别内核可能被提交至错误队列的情况。实践中，我们预期该属性不会广泛使用，而缓冲区能在任意设备、任意上下文中被访问的能力，正是缓冲区抽象最具威力的特性之一（此属性恰好取消了该特性）。  

### 缓冲区的用途探析（What Can We Do with a Buffer?）
缓冲区对象可执行多种操作。我们能够<font style="color:#DF2A3F;">查询缓冲区的特性，判断缓冲区销毁后数据是否及何时回写至主机内存，或将其重新解释为具有不同特性的缓冲区</font>。然而，<font style="color:#DF2A3F;background-color:#FBF5CB;">有一项操作不可实现：直接访问缓冲区所表示的数据</font>。为此，必须创建访问器（accessor）对象来实现数据访问——本章后续内容将对此展开详细阐述。

关于缓冲区可查询内容的示例包括其范围、所表示的数据元素总数，以及存储其元素所需的字节数。我们还可以查询该缓冲区正在使用哪个分配器对象，以及该缓冲区是否为子缓冲区。  

在缓冲区被销毁时更新主机内存是使用缓冲区时需考虑的重要问题。根据缓冲区的创建方式，主机内存可能不会在缓冲区销毁后更新计算结果。若缓冲区通过指向非常量（non-const）数据的主机指针创建并初始化，该指针将在缓冲区销毁时同步最新数据。但无论缓冲区如何创建，均可通过特定方法强制更新主机内存——`set_final_data`作为缓冲区的模板方法，可接收原始指针、C++输出迭代器或`std::weak_ptr`参数。当缓冲区销毁时，其包含的数据将写入指定主机存储位置。需注意：若缓冲区最初通过非常量主机指针初始化，其行为等同于以该指针调用`set_final_data`。从技术角度看，原始指针属于输出迭代器的特例。若传入`std::weak_ptr`参数且指针已失效或被删除，则不会执行主机数据写入。写入行为还可通过`set_write_back`方法进行控制。  

## 访问器（Accessors）
缓冲区所存储的数据不能直接通过缓冲区对象进行访问。相反，我们<font style="color:#DF2A3F;background-color:#FBF5CB;">必须创建访问器对象来安全地获取缓冲区数据</font>。<font style="background-color:#E8F7CF;">访问器会向运行时系统声明数据访问的位置和方式，从而使运行时能够确保在正确的时间将正确的数据置于正确的位置</font>。这一机制具有强大的功能，尤其当与任务图（该任务图会部分基于数据依赖性来调度内核执行）结合使用时效果更为显著。  

访问器对象是从模板化的访问器类实例化而来的。该类具有五个模板参数。第一个参数是被访问数据的类型，该类型应与数据本身的类型保持一致，由对应的缓冲区存储。同样，第二个参数描述数据与缓冲区的维度，默认值为1。  

![Figure 7-6. Access modes](https://cdn.nlark.com/yuque/0/2025/png/33636091/1743137171556-cd140904-7e4d-4f2a-820d-a43a4759f32b.png)

![Figure 7-7. Access targets](https://cdn.nlark.com/yuque/0/2025/png/33636091/1743137293152-b8c531bc-1494-4be0-9ac5-f122801f8efb.png)

接下来的三个模板参数是访问器所特有的。其中第一个参数是访问模式。访问模式描述了我们在程序中如何使用访问器，可能的模式如图7-6所示。我们将在第8章学习<font style="background-color:#E8F7CF;">如何利用这些模式来调度内核执行顺序及实现数据传输</font>。<font style="background-color:#E8F7CF;">若未显式指定或自动推断访问模式参数，该参数将具有默认值——对于非常量（non-const）数据类型默认采用读写模式</font>，对于常量数据类型则默认采用只读模式。这些默认设置始终正确无误，但提供更精确的信息可能有助于运行时系统优化性能。在应用开发初期，不显式指定访问模式既安全又简洁，待性能关键区域完成性能剖析后，可再据此优化访问模式。  

下一个模板参数是访问目标。<font style="background-color:#E8F7CF;">缓冲区是数据的抽象，并不描述数据的存储位置和方式</font>。访问目标则规定了我们访问数据的具体位置。图7-7列出了两种可能的访问目标类型。  

在使用C++配合SYCL时，仅存在两种访问目标：device（设备端）和host_task（主机任务）。默认模板值为device，这意味着我们计划在设备端访问缓冲区数据。这种设定是合理的，因为访问器最常用于设备端操作（如内核函数或数据传输）。另一种访问目标是<font style="color:#DF2A3F;">host_task</font>，<font style="background-color:#E8F7CF;">当主机任务需要访问缓冲区数据时使用该选项</font>。  

设备（device）可能配备不同类型的内存。特别是，许多设备具有某种快速的本地内存，可在工作组内的多个工作项之间共享。早期版本的SYCL对本地内存设有专用访问目标，但SYCL 2020采用了不同的处理方式。我们将在第9章学习<font style="background-color:#FBF5CB;">如何使用工作组本地内存</font>。   
早期版本的SYCL还为宿主机（除SYCL 2020新增的宿主任务外）设定了专用访问目标。现已被新的`<font style="color:#DF2A3F;">host_accessor</font>`类取代，<font style="background-color:#E8F7CF;">该类允许在宿主代码中访问缓冲区的数据</font>。然而，该访问仅在`host_accessor`的生命周期内保持有效。需要注意的是，<font style="color:#DF2A3F;">只要</font>`<font style="color:#DF2A3F;">host_accessor</font>`<font style="color:#DF2A3F;">处于有效状态，缓冲区就会被锁定于宿主机</font>，因此应特别注意限制`host_accessor`对象的作用域。  

最终模板参数控制访问器是否为占位访问器。程序员通常不会直接设置此参数，其值一般通过用于创建访问器的构造函数调用来推导。占位访问器是指在命令组外部声明，但旨在用于访问内核内设备数据的访问器。当我们查看访问器创建示例时，将了解占位访问器与非占位访问器的区别。  

虽然可以通过缓冲区对象的`get_access`方法提取访问器，但更简便的方式是直接创建（构造）它们。在后续示例中我们将采用这种风格，因其理解简单且代码简洁。  

### 访问器创建（Accessor Creation）
图7-8展示了一个包含访问器入门所需全部要素的示例程序。本例中设有三个缓冲区A、B和C。我们提交至队列的首个并行任务会为每个缓冲区创建访问器，并定义使用这些访问器初始化缓冲区数值的内核。每个访问器通过引用目标缓冲区及命令组中定义的handler对象来构造，该命令组正被提交至队列。这种构造方式将访问器有效绑定至作为命令组组成部分提交的内核。常规访问器属于设备访问器，因其默认操作目标是存储在设备内存中的全局缓冲区——这也是最常见的使用场景。  

```cpp
#include <cassert>
#include <sycl/sycl.hpp>
using namespace sycl;
constexpr int N = 42;

int main() {
    queue q; // 创建队列
    // 创建3个包含42个整数的缓冲区
    buffer<int> a_buf{range{N}};
    buffer<int> b_buf{range{N}};
    buffer<int> c_buf{range{N}};
    accessor pc{c_buf};

    q.submit([&](handler &h) {
        accessor a{a_buf, h};
        accessor b{b_buf, h};
        accessor c{c_buf, h};
        h.parallel_for(N, [=](id<1> i) {
            a[i] = 1;
            b[i] = 40;
            c[i] = 0;
        });
    });
    q.submit([&](handler &h) {
        accessor a{a_buf, h};
        accessor b{b_buf, h};
        accessor c{c_buf, h};
        h.parallel_for(N, [=](id<1> i) {
            c[i] += a[i] + b[i];
        });
    });
    q.submit([&](handler &h) {
        h.require(pc);
        h.parallel_for(N, [=](id<1> i) {
            pc[i]++;
        });
    });
    host_accessor result{c_buf};
    for (int i = 0; i < N; i++) {
        assert(result[i] == N);
    }
    return 0;
}
```

 我们提交的第二个任务同样为缓冲区定义了三个访问器。随后在第二个内核中，我们通过这些访问器将缓冲区A与B中的元素相加至缓冲区C。由于该任务与首个任务操作的是相同数据集，运行时将在首个任务完成后执行此任务。我们将在下一章节对此进行详细阐述。  

 第三项任务展示了如何使用占位符访问器。访问器`pC`在创建缓冲区后，于图7-8示例的开头声明。请注意，由于没有可传递的处理程序对象，构造函数未接收该参数。这使我们能够提前创建可重复使用的访问器对象。然而，为了在内核中使用该访问器，我们需要在提交时将其绑定到命令组。我们通过处理程序对象的`require`方法实现此操作。一旦将占位符访问器绑定到命令组，便可像使用其他访问器一样在内核中调用它。  

 最后，我们创建一个host_accessor对象以便在主机上读取计算结果。需要注意的是，这与内核中使用的类型不同。此示例中的主机访问器同样不需要传入handler对象，因为我们依然没有可传递的handler。主机访问器的特殊类型还能帮助我们将其与占位符区分开。主机访问器的一个重要特性是：其构造函数仅在数据可供主机使用时才会完成，这意味着主机访问器的构造过程可能显得耗时较长。构造函数必须等待所有生成待拷贝数据的内核执行完毕，同时还需等待拷贝操作本身完成。一旦主机访问器构造完成，就能安全地在主机上直接使用其访问的数据，我们可确保主机获取的是该数据的最新版本。  

 虽然这个示例完全正确，但我们在创建访问器时并未说明其预期用途。实际上，我们对缓冲区中的非常量整型数据使用了默认的读写访问模式。这种做法可能过于保守，且可能 在操作之间产生不必要的依赖或多余的数据移动。若运行时系统能更全面地了解我们计划如何使用所创建的访问器，它或许能实现更优的调度。不过在展开具体示例之前，我们还需引入另一个工具——推导标签(deduction tag)。 

推导标签（deduction tags）是一种简洁表达访问器所需访问模式与目标组合的方式。使用时，推导标签作为参数传递给访问器的构造函数，其可选标签如图7-9所示。当访问器通过标签参数构造时，C++的类模板参数推导（CTAD）机制能正确推导出预期的访问模式与目标，从而提供覆盖模板参数默认值的便捷方式。虽然也可手动指定模板参数，但标签能以更简洁的方式实现相同效果，无需完整拼写模板化的访问器。  

![Figure 7-9. Deduction tags](https://cdn.nlark.com/yuque/0/2025/png/33636091/1743137741538-0a603278-636c-42ed-80d8-bc5cac2a2b92.png)

 让我们以之前的示例为基础进行改写，加入演绎标签。这一优化后的新示例展示于图7-10中。  

```cpp
#include <cassert>
#include <sycl/sycl.hpp>
using namespace sycl;
constexpr int N = 42;

int main() {
  queue q;
  // 创建3个包含42个整数的缓冲区
  buffer<int> buf_a{range{N}};
  buffer<int> buf_b{range{N}};
  buffer<int> buf_c{range{N}};

  accessor pc{buf_c};

  q.submit([&](handler& h) {
    accessor a{buf_a, h, write_only, no_init};
    accessor b{buf_b, h, write_only, no_init};
    accessor c{buf_c, h, write_only, no_init};
    h.parallel_for(N, [=](id<1> i) {
      a[i] = 1;
      b[i] = 40;
      c[i] = 0;
    });
  });
  q.submit([&](handler& h) {
    accessor a{buf_a, h, read_only};
    accessor b{buf_b, h, read_only};
    accessor c{buf_c, h, read_write};
    h.parallel_for(N, [=](id<1> i) { c[i] += a[i] + b[i]; });
  });
  q.submit([&](handler& h) {
    h.require(pc);
    h.parallel_for(N, [=](id<1> i) { pc[i]++; });
  });

  host_accessor result{buf_c, read_only};

  for (int i = 0; i < N; i++) {
    assert(result[i] == N);
  }

  return 0;
}
```

 我们首先按照图7-8所示声明缓冲区，并创建稍后将使用的占位访问器。现在来看提交到队列的第一个任务：此前我们通过传递缓冲区引用和命令组的处理对象来创建访问器，现在构造函数调用中新增了两个参数。第一个新参数是推导标签（deduction tag），由于该内核负责为缓冲区写入初始值，我们使用write_only推导标签，以此告知运行时该内核将生成新数据且不会读取缓冲区内容。  

 第二个新参数是一个可选的访问器属性，类似于本章前面提到的缓冲区可选属性。我们传入的no_init属性让运行时知晓可以丢弃缓冲区的原有内容。这一特性非常实用，因为它能帮助运行时消除不必要的数据迁移。在本示例中，由于首个任务是为缓冲区写入初始值，运行时无需在内核执行前将未初始化的主机内存拷贝至设备。no_init属性对此案例颇有裨益，但不应将其用于需要读取-修改-写入的场景，或仅更新缓冲区部分数值的内核操作。  

 我们提交到队列的第二个任务与之前相同，但现在为访问器添加了推导标签。此处我们为访问器aA和aB添加了read_only标签，以告知运行时系统后续仅通过这些访问器读取缓冲区A和B的值。第三个访问器aC则被赋予read_write推导标签，因为我们需要将A、B元素的累加和写入C。示例中为保持一致性显式使用了该标签，但由于默认访问模式本就是read_write，此操作实非必要。  

 默认用法在第三个任务中得以保留，此处我们使用占位访问器。这与图7-8所示简化示例保持完全一致。当我们创建最终的主机访问器结果时，其现在会接收一个推导标签。由于我们仅需读取主机端的最终数值，因此向构造函数传递了只读标签。若我们将该程序经过重写后，主机访问器被销毁。此时若启动另一个对缓冲区C进行操作的内核，由于read_only标记已使运行时系统知晓该缓冲区不会被主机修改，因此无需将其写回设备。    

### 访问器的用途探析（What Can We Do with an Accessor?）
访问器对象可实现多种功能，但其核心作用正如其名所示——数据访问。通常通过访问器的[]运算符实现这一功能，如图7-8和7-10示例所示。该运算符可接收两种参数：能正确索引多维数据的id对象，或单个size_t值（适用于多维访问器情况）。后者会返回一个待继续索引的对象，直到获取标量值为止，例如二维场景下表现为a[i][j]的形式。需注意访问器维度顺序遵循C++惯例：最右侧维度为单元步长维度（迭代"速度最快"）。  

访问器也可以返回指向底层数据的指针。该指针可遵循常规C++规则直接访问。需注意的是，该指针的地址空间可能涉及额外的复杂性。  

通过访问器对象还可以查询许多信息。例如，可访问元素的数量、其所覆盖缓冲区区域的字节大小，或可访问数据的范围等。  

 访问器提供了与C++容器类似的接口，可在许多需要传递容器的场景中使用。访问器所支持的容器接口包括`data`方法（其功能等同于`get_pointer`），以及多种前向与反向迭代器实现。  

## 总结
在本章中，我们学习了缓冲区和访问器。缓冲区是对数据的抽象，它向程序员隐藏了内存管理的底层细节，旨在提供一个更简单、更高层次的抽象概念。通过多个示例，我们探讨了构建缓冲区的不同方法，以及可指定的各种可选属性来改变其行为。我们掌握了如何用主机内存中的数据初始化缓冲区，也学会了在完成缓冲区操作后如何将数据写回主机内存。  

由于我们无法直接访问缓冲区，因此学会了通过访问器对象来访问缓冲区中的数据。我们理解了设备访问器与主机访问器的区别，探讨了不同访问模式与目标的作用，以及它们如何向运行时系统表明程序将如何使用访问器。我们展示了使用默认访问模式与目标的最简访问器用法，并学会如何区分占位访问器与非占位访问器。随后通过为访问器声明添加推导标签，演示了如何向运行时系统提供更多访问器使用信息以进一步优化示例程序。最后，我们全面介绍了访问器在程序中的多种应用方式。  

下一章我们将更详细地学习：运行时系统如何利用我们通过访问器提供的信息来调度不同内核的执行。我们还将了解这些信息如何告知运行时系统——缓冲区数据需要在主机与设备之间进行拷贝的时机及方式。此外，我们将掌握如何显式控制涉及缓冲区的数据移动（同样适用于USM分配机制）。  

